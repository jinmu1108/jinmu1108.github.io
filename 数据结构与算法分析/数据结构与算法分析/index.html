<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法分析 | J1Nmu</title><meta name="author" content="Jinmu"><meta name="copyright" content="Jinmu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法分析 概念 \1. 数据：数据是客观事物的符号表示，是所有能输入计算机中被计算机程序处理的符号的总称。 \2. 数据元素：数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 \3. 数据项：数据项是组成数据元素的、有独立含义的的、不可分割的最小单位。 \4. 数据对象"><link rel="shortcut icon" href="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/liujin.jpg"><link rel="canonical" href="https://jinmu1108.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-21 08:55:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/liujin.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1Nmu</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-20T14:53:52.858Z" title="发表于 2023-12-20 22:53:52">2023-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-21T00:55:43.673Z" title="更新于 2023-12-21 08:55:43">2023-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">数据结构与算法分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>数据结构与算法分析</h1>
<h2 id="概念">概念</h2>
<p>\1. 数据：数据是客观事物的符号表示，是所有能输入计算机中被计算机程序处理的符号的总称。</p>
<p>\2. 数据元素：数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。</p>
<p>\3. 数据项：数据项是组成数据元素的、有独立含义的的、不可分割的最小单位。</p>
<p>\4. 数据对象：数据对象是性质相同的数据元素的集合，是数据的一个子集。</p>
<p><strong>\5. 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。</strong></p>
<p><strong>\6. 逻辑结构：逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。</strong></p>
<p><strong>7.</strong> <em><strong>*数据元素的四种关系：*</strong></em></p>
<p>集合结构：数据元素之间除了“属于同一集合”关系外，别无其它关系。</p>
<p>线性结构：数据结构之间存在一对一的关系。</p>
<p>树结构：数据元素之间存在一对多的关系。</p>
<p>图结构或网状结构：数据结构之间存在多对多的关系。</p>
<p><strong>\8. 存储结构：数据对象在计算机中的存储表示。（物理结构）</strong></p>
<p><strong>（1）顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系的，通常借助程序设计语言的数组类型来描述。（2）链式存储结构：无需占用一整块空间，但为了表示结点间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。</strong></p>
<p>\9. 数据类型：是一个值的集合和定义在这个值集上的一组操作的总称。</p>
<p>\10. 抽象数据类型：一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，包括数据对象、数据对象上关系的集合、数据对象的基本操作的集合。</p>
<p>\11. 算法的定义及特性：</p>
<p>（1）有穷之：一个算法必须总是在执行又穷步后结束，且每一步都必须在有穷时间内完成。</p>
<p>（2）确定性：对于每种情况下所应执行的操作，在算法中都有确定的规定，不会产生二义性，算法的执行者或阅读者都能明确其含义及然后执行。</p>
<p>（3）可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</p>
<p>（4）输入：一个算法有0个或多个输入。</p>
<p>（5）输出：一个算法有一个或多个输出。</p>
<p>\12. 评判算法优劣的基本标准：正确性、可读性、健壮性、高效性。</p>
<p>\13. 问题规模：是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。</p>
<p>\14. 语句频度：一条语句的重复执行次数</p>
<p><strong>\15. 时间复杂度：T(n)=O(f(n))随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。</strong></p>
<p>\16. 平均时间复杂度：指算法在所有可能情况下，按照输入实例等概率出现时，算法计算量的加权平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\17. 线性表：由n（n&gt;=0）个数据特性相同的元素构成的有限序列。（n=0时为空表）</span><br><span class="line">顺序表</span><br><span class="line">线性表的顺序表示又被称为顺序存储结构或顺序映像</span><br><span class="line">广义表(Lists，又称列表)是一种非连续性的数据结构，是线性表的一种推广。</span><br></pre></td></tr></table></figure>
<p>\18. 单链表定义：（1）数据域：存储数据元素信息的域（2）指针域：存储直接后继存储位置的域（3）指针（链）：指针域中存储的信息。</p>
<p><strong>\19. 栈：限定仅在表尾进行插入或删除操作的、后进先出的线性表，</strong></p>
<p><strong>\20. 队列：只允许在表的一端插入，在另一端删除元素，先进先出的线性表。</strong></p>
<p>\21. 递归：在一个函数、过程或者数据结构定义的内部有直接（或间接）出现定义本身的应用。</p>
<p>\22. 活动记录：每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必须是递归工作栈栈顶的工作记录。</p>
<p>\23. 循环队列：将顺序队列变为一个环状的空间。</p>
<p>\24. 串：由零个或多个字符组成的有限空间，记为（s=”a1a2…an”）.</p>
<p>\25. 模式匹配：字串的定位运算。</p>
<p>\26. 特殊矩阵：值相同的元素或者零元素在矩阵中分布有一定的规律。</p>
<p>\27. 稀疏矩阵：非零元素比零元素少，分布没有一定的规律的矩阵。</p>
<p>\28. 树的基本术语：（1）结点：树中的一个独立单元，包含一个数据结构及若干指向其子树的分支。（2）结点的度：结点拥有的子树数称为结点的度。（3）树的度：树内各结点度的最大值。（4）叶子：度为0的结点.（5）非终端节点：度不为0的结点。（6）双亲和孩子：节点的子树的根。（7）兄弟：同一个双亲的孩子之间互称兄弟。（8）祖先：从根到该结点所经分支上的所有结点。（9）树的深度：树中结点的最大层次。（10）有序树：如果将树中结点的各子树看成从左到右是有次序的，则称有序树。（11）m（m&gt;=0）棵互不相交的树的集合。</p>
<p><strong>\29. 二叉树：n(n&gt;=0)个结点所构成的集合（或为空树，或为非空树）。</strong></p>
<p>对于非空树：（1）有且仅有一个称之为根的节点。（2）除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，T1和T2都是二叉树。</p>
<p>二叉树与树区别：（1）二叉树每个结点至多只有两棵子树。（2）二叉树的子树有左右之分，次序不能颠倒。</p>
<p><strong>\30. 满二叉树：深度为k且含有2^k-1个结点的二叉树。</strong></p>
<p><strong>\31. 完全二叉树：深度为k的、有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应的二叉树。</strong></p>
<p>\32. 遍历二叉树：指按某条搜索路径寻访树中的每个结点，使得每个结点均被访问一次，且只访问一次。</p>
<p><strong>\33. 哈夫曼树（最优树）：假设有m个权值{w1，w2,…,wm},可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权值为wi，则其中带权路径WPL最小的二叉树称为哈夫曼树。</strong></p>
<p>\34. 前缀编码：如果在一个编码方案中，任意一个编码都不是其他任何编码的前缀，则为前缀编码。</p>
<p><strong>\35. 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，对每个右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串称为哈夫曼编码。</strong></p>
<p><strong>\36. 哈夫曼编码是前缀编码：哈夫曼编码是根到叶子路径上的编码序列。由树的特点可知，若路径A是另一条路径B的最左部分，B经过了A，则A的终点一定不是叶子。而哈夫曼编码对应路径的终点一定为叶子，所有任意哈夫曼编码都不会与其他哈夫曼编码前缀编码完全重叠。</strong></p>
<p><strong>\37. 哈夫曼编码是最优前缀编码：对于包括n个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。</strong></p>
<p><strong>\38. 关键路径：一条源点到汇点的带权路径长度最长的路径。</strong></p>
<p><strong>\39. 关键活动：关键路径上的活动。</strong></p>
<p><strong>\40. 带权路径长度(WPL)：在AOE-网中，一条路径各弧上的权值之和。</strong></p>
<p>\41. 查找表：同一类型的数据元素（或记录）构成的集合。</p>
<p>\42. 二叉排序树：或者是一棵空树，或者是（1）若它的左子树不空，则左子树上所有节点上的值小于它根节点的值（2）若它的右子树不空，则右子树上所有节点上的值大于它根节点的值（3）他的左右子树分别是二叉排序树。</p>
<p>\43. 平衡二叉树：一棵二叉排序树，左子树和右子树的深度差的绝对值不超过1，且左子树和右子树也是平衡二叉树。</p>
<p>\44. 平衡因子：该节点左子树和右子树的深度差（-1，0，1）。</p>
<p>\45. 散列函数、散列地址：在记录的存储位置p和关键字key之间建立一个确定的对应关系H，使p=H（key），H为散列函数，p为散列地址。</p>
<p>\46. 散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。</p>
<p>\47. 冲突、同义词：对不同的关键字可能得到同一散列地址，即key1!=key2,而H(key1)=H(key2),称为冲突。具有相同函数值的关键字为同义词。</p>
<p>\48. 散列表的装填因子：a=表中填入的记录数/散列表的长度。</p>
<p>\49. 排序稳定、不稳定：假设关键字Ki=Kj(1&lt;=i&lt;=n,1&lt;=j&lt;=n,i!=j),且在排序前的序列中Ri领先于Rj，而在排序后Ri仍然领先于Rj，则稳定，反之不稳定。</p>
<p>\50. 内部排序：待排序记录全部存放在计算机内存中进行排序的过程。</p>
<p>\51. 外部排序：待排序记录的数量很大，内存一次不能容纳全记录，排序过程中需对外存进行访问的排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对二叉树按某种遍历次序使其变为线索二叉树的过程叫做线索化</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线性表">线性表</h2>
<h4 id="线性结构定义">线性结构定义</h4>
<p>若结构是非空有限集,则有且仅有一个开始结点和一个终端结点,并且所有结点都最多只有一个直接前驱和一个直接后继</p>
<h4 id="线性结构特点">线性结构特点</h4>
<ol>
<li>存在唯一的一个被称做&quot;第一个&quot;的数据元素</li>
<li>存在唯一的一个被称作&quot;最后一个&quot;的数据元素</li>
<li>除第一个之外,每个元素都只有一个前驱</li>
<li>除最后一个之外,每个元素都只有一个后继</li>
</ol>
<p><strong>线性结构反映结点间的逻辑关系是<code>一对一</code>的</strong></p>
<p>线性结构包括线性表,栈,队列,字符串,数组等等,其中,最典型,最常用的是-----<strong>线性表</strong></p>
<h3 id="顺序表">顺序表</h3>
<p>线性表的顺序表示又被称为顺序存储结构或顺序映像</p>
<ul>
<li>顺序存储定义</li>
</ul>
<p>把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构</p>
<ul>
<li>顺序存储方法</li>
</ul>
<p>用一组地址连续的存储单元依次存储线性表的元素,可通过数组来实现</p>
<p>线性表&lt;&lt;==&gt;&gt;逻辑结构</p>
<p>顺序表&lt;&lt;==&gt;&gt;存储结构</p>
<h4 id="顺序表-顺序存储结构-的特点">顺序表(顺序存储结构)的特点</h4>
<ol>
<li>利用数据元素的存储位置表示线性表中相邻数据元素之间1的前后关系,即<strong>线性表的逻辑结构与存储结构一致</strong></li>
<li>在访问线性表时,可以快速地计算出任何一个数据元素的存储地址.因此可以粗略地认为,访问<strong>每个元素所花时间相等</strong></li>
</ol>
<p>这种存取元素的方法被称为<code>随机存取法</code></p>
<h4 id="顺序表的优缺点">顺序表的优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>存储密度大(结点本身所占存储量/结点结构所占存储量)</li>
<li>可以随机存取表中任一元素</li>
</ul>
<p>缺点</p>
<ul>
<li>在插入,删除某一元素时,需要移动大量元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式,数据元素的个数不能自由扩充</li>
</ul>
<p>为克服这一缺点==&gt;&gt;<strong>链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="built_in">list</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">list</span>-&gt;capacity + (<span class="built_in">list</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, newCapacity * <span class="keyword">sizeof</span>(E));</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">list</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] == element) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表">链表</h3>
<ul>
<li>线性链表定义</li>
</ul>
<p>用一组任意的存储单元存储线性表中的数据元素,对每个数据元素除了保存自身信息外,还保存了直接后继元素的存储位置</p>
<ul>
<li>链式存储</li>
</ul>
<p>结点在存储器中的位置是任意的,即逻辑上相邻的数据元素在物理上不一定相邻</p>
<h4 id="链式存储有关的术语">链式存储有关的术语</h4>
<p><code>结点</code>:数据元素的存储映像.由数据域和指针域两部分组成</p>
<p><code>数据域</code>:存储数据元素信息的域</p>
<p><code>指针域</code>:存储直接后继存储位置的域</p>
<p><code>链(指针)</code>:指针域中存储的信息</p>
<p><code>链表</code>:n个结点由指针链组成一个链表.它是线性表的链式存储映像,称为线性表的链式存储结构</p>
<p><code>头节点</code>:是指向链表中第一个结点的指针</p>
<p><code>首元结点</code>:是指链表中存储的第一个数据元素的结点</p>
<p><code>头节点</code>:是在链表的首元结点之前附设的一个结点;数据域内只放空表标志和表长等信息</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/8(QM353TWHMFSXNDBAKRR)7.png" alt="8(QM353TWHMFSXNDBAKRR)7"></p>
<h4 id="链表-链式存储结构-的特点">链表(链式存储结构)的特点</h4>
<ol>
<li>结点在存储器中的位置是任意的，即逻辑上相 邻的数据元素在物理上不⼀定相邻 链表（链式存储结构）的特点</li>
<li>访问时只能通过头指针进入链表，并通过每个 结点的指针域向后扫描其余结点，所以寻找第一个 结点和最后一个结点所花费的时间不等</li>
</ol>
<p>这种存取的方法被称为顺序存取法</p>
<h4 id="链表的优缺点">链表的优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>数据元素的个数可以自由扩充</li>
<li>插入,删除等操作不必移动数据,只需修改链接指针,修改效率较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>存储密度小</li>
<li>存取效率不高,必须采用顺序存取,即存取数据元素时,只能按链表的顺序进行访问</li>
</ul>
<p><strong>顺序存储和链接存储比较</strong></p>
<p>顺序存储和链接存储是数据的两种最基本的存储结构。</p>
<ul>
<li>在顺序存储中，每个存储结点只含有所存元素本身的 信息,元素之间的逻辑关系是通过数组下标位置简单 计算出来的。随机存取</li>
<li>在链接存储中，每个存储结点不仅含有所存元素本身 的信息，而且含有元素之间逻辑关系的信息。必须采用顺序存取</li>
</ul>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/1.png" alt="1"></p>
<p><strong>结点只有一个指针域的链表,称为单链表或线性链表</strong></p>
<p><strong>有两个指针域的链表,称为双链表</strong></p>
<p><strong>首尾相接的链表称为循环链表</strong></p>
<p>无头节点时,头指针为空时表示空表</p>
<ul>
<li>在链表中设置头结点有什么好处？</li>
</ul>
<ol>
<li><strong>便于首元结点的处理</strong> 首元结点的地址保存在头结点的指针域中, 所以在链表的第一个位置上的操作和其它位置 一致，无须进行特殊处理;</li>
<li><strong>便于空表和非空表的统一处理</strong> 无论链表是否为空，头指针都是指向头结 点的非空指针，因此空表和非空表的处理也就 统一了。</li>
</ol>
<p><strong>头节点的数据域内装的是什么?</strong></p>
<p>头结点的数据域可以为空，也可存放线性表长度等 附加信息，但此结点不能计入链表长度值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//大体和上面是一样的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node tmp = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--index);</span><br><span class="line">    <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;element == element) <span class="keyword">return</span> i;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表">双向链表</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">	E element;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (--index) &#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node node = (Node )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	node-&gt;element = element;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head-&gt;next) &#123;</span><br><span class="line">		head-&gt;next-&gt;prev = node;</span><br><span class="line">		node-&gt;next = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;next = node;</span><br><span class="line">	node-&gt;prev = head;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">	initNode(&amp;head);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)  <span class="comment">//插5个元素吧</span></span><br><span class="line">		insertList(&amp;head, i * <span class="number">100</span>, i);</span><br><span class="line"></span><br><span class="line">	Node node = &amp;head;   <span class="comment">//先来正向遍历一次</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">	&#125; <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   <span class="comment">//再来反向遍历一次</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">		node = node-&gt;prev;</span><br><span class="line">	&#125; <span class="keyword">while</span> (node-&gt;prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="队列">队列</h3>
<h4 id="队列的特点">队列的特点</h4>
<ul>
<li>队列的定义</li>
</ul>
<p>队列是限定仅能在表头进行删除,表尾进行插入的线性表</p>
<ul>
<li>逻辑结构</li>
</ul>
<p>与线性表相同仍为一对一关系</p>
<ul>
<li>存储结构</li>
</ul>
<p>用顺序队列或链队存储均可</p>
<ul>
<li>运算规则</li>
</ul>
<p>先进先出(FIFO)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">	E* <span class="built_in">array</span>;</span><br><span class="line">	<span class="type">int</span> capacity;</span><br><span class="line">	<span class="type">int</span> rear, front;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>* <span class="title">ArrayQueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">initQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = (E *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">offerQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>, E element)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity == <span class="built_in">queue</span>-&gt;front)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">	<span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;rear] = element;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt; &quot;</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (i != <span class="built_in">queue</span>-&gt;rear);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">	initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		offerQueue(&amp;<span class="built_in">queue</span>, i * <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="树的定义和基本术语">树的定义和基本术语</h2>
<h3 id="树的定义和基本术语-2">树的定义和基本术语</h3>
<h4 id="树的定义">树的定义</h4>
<p>树是由 n (n≥ 0) 个结点组成的有限集合。</p>
<p>• 如果n= 0，称为空树；</p>
<p>• 否则，在一棵非空树中(n&gt;0) ，满足如下两个条件：</p>
<p>（1）有且仅有一个特定的称之为根(root) 的结点，它只有直接后 继，但没有直接前驱；</p>
<p>（2）除根以外的其它结点划分为 m (m ≥ 0) 个互不相 交的有限集 合 T0,T1, …, Tm-1，每个集合又是一棵树，并且称之为根的 子树(subTree)。</p>
<p><strong>树是由 n (n≥ 0) 个结点组成的有限集合</strong></p>
<p><strong>结点: 包含一个数据元素及指向其子树的分支</strong></p>
<p><strong>根结点: 非空树中无前驱结点的节点</strong></p>
<p><strong>结点的度(degree): 结点拥有的子树数</strong></p>
<p><strong>树的度: 树内各节点的度的最大值</strong></p>
<p><strong>树的深度(高度): 树中 结点的最大层次</strong></p>
<p><strong>有序树: 树中结点的各子树从左至右是有次序的（最左边为第一个孩子）</strong></p>
<p><strong>无序树: 树中结点的各子树无次序</strong></p>
<p><strong>森林: 是m(m≥ 0)棵不补相交的树的集合</strong></p>
<h3 id="树的基本操作-抽象数据类型见二叉树">树的基本操作 (抽象数据类型见二叉树)</h3>
<p>① 初始化</p>
<p>② 求指定结点所在树的根结点</p>
<p>③ 求指定结点的双亲结点</p>
<p>④ 求指定结点的某一孩子结点</p>
<p>⑤ 求指定结点的最右边兄弟结点</p>
<p>⑥ 将一棵树插入到另一树的指定结点下作为它的子树</p>
<p>⑦ 删除指定结点的某一子树</p>
<p>⑧ 树的遍历</p>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树的定义">二叉树的定义</h3>
<p>二叉树（Binary Tree）或为空树，或由一个根节点及两棵 不相交的左子树、右子树构成，并且左、右子树本身也是 二叉树。</p>
<h3 id="二叉树的特点">二叉树的特点</h3>
<p>1）二叉树中每个结点最多有两棵子树；二叉树每个结点度小于等于2;</p>
<p>2）左、右子树不能颠倒——有序树;</p>
<p>3）二叉树可以是空集合，根可以有空的左子树或空的右子树。</p>
<p><strong>二叉树不是树的特殊情况，它们是两个概念</strong></p>
<h3 id="二叉树的性质">二叉树的性质</h3>
<p>性质1：在二叉树的第i层上至多有2i-1个结点(i≥1)</p>
<p>性质2：深度为k的二叉树最多有2k -1个结点。(k≥1)</p>
<p>性质3：对任何一棵二叉树, 如果其叶结点个数为n0, 度为2的非叶结点个数为n2, 则有n0＝n2＋1。</p>
<p>性质4: 具有n个结点的完全二叉树的深度为<img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026221928022.png" alt="image-20231026221928022"></p>
<p>性质5: 对于具有n个结点的完全二叉树，如果按照从上到下和 从左到右的顺序对二叉树中的所有结点从1开始顺序编号，则 对于任意的序号为i的结点有：</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026222005463.png" alt="image-20231026222005463"></p>
<h3 id="满二叉树">满二叉树</h3>
<p>深度为k且有2k-1个结点的二叉树。</p>
<h4 id="特点">特点:</h4>
<ol>
<li>
<p>在满二叉树中，每层 结点都是满的，即每 层结点都具有最大结 点数；</p>
</li>
<li>
<p>叶子结点全部在底层 对满二叉树结点位置进行编号 • 编号规则: 从根开始，自上而下，自左向右 • 每一结点位置都有元素</p>
</li>
</ol>
<p><strong>满二叉树在同样深度的二叉树中结点个数最多</strong></p>
<p><strong>满二叉树在同样深度的二叉树中叶子结点个数最多</strong></p>
<h3 id="完全二叉树">完全二叉树</h3>
<p>若设二叉树的高度为h，除第 h层外，其它各层的结点数都 达到最大个数，第h层的结点集中出现在左端若干连续位置 上，这就是完全二叉树。</p>
<p>深度为h的具有n个结点的二叉树，当且仅当其每一个结点 都与深度为h的满二叉树中编号为1~n的结点一一对应时， 称之为完全二叉树。</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026221637661.png" alt="image-20231026221637661"></p>
<p>在满二叉树中，从最后一 个结点开始，连续去掉任意个 结点，即是一棵完全二叉树</p>
<h4 id="特点：">特点：</h4>
<ol>
<li>叶子只可能分布在层次最大的两层上</li>
<li>
<ol start="2">
<li>对任一结点，如果其右子树最大层次为i，则其左子树 的最大层次必为i或i+1</li>
</ol>
</li>
</ol>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026221838020.png" alt="image-20231026221838020"></p>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<h4 id="二叉树的顺序存储">二叉树的顺序存储</h4>
<p>实现: 按满二叉树的节点层次编号，依次存放二叉树中的数据元素</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026223759447.png" alt="image-20231026223759447"></p>
<p>缺点:</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026223920117.png" alt="image-20231026223920117"></p>
<h4 id="二叉树的链式存储">二叉树的链式存储</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026224034231.png" alt="image-20231026224034231"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">lchild</span>;</span> <span class="comment">//左孩子指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">rchild</span>;</span> <span class="comment">//右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>在n个结点的二叉链表中，有n+1个空指针域</p>
<h4 id="三叉链表">三叉链表</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231026225118347.png" alt="image-20231026225118347"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> * <span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> * <span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br></pre></td></tr></table></figure>
<h3 id="遍历二叉树">遍历二叉树</h3>
<p><strong>树的遍历: 顺着某一条搜索路径巡访树中的结点，使得每个结点均被 访问*一次，而且只被访问一次（又称周游）</strong></p>
<p>遍历的目的: 得到树中所有结点的一 个线性排列</p>
<p>遍历的用途: 它是树结构插入、删除、 修改、查找和排序运算的前提，是二 叉树一切运算的基础和核心</p>
<p><strong>令: L—遍历左子树 D—访问根结点 R—遍历右子树</strong></p>
<p>则遍历整个二叉树的方案共有: DLR、LDR、LRD、DRL、RDL、RLD 六种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若规定先左后右，则只有三种情况：</span><br><span class="line">DLR——先（根）序遍历，</span><br><span class="line">LDR——中（根）序遍历，</span><br><span class="line">LRD——后（根）序遍历。</span><br></pre></td></tr></table></figure>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231027084548107.png" alt="image-20231027084548107"></p>
<h4 id="先序遍历二叉树">先序遍历二叉树</h4>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 访问根结点;</p>
<p>(2) 先序遍历左子树;</p>
<p>(3) 先序遍历右子树。</p>
<h4 id="中序遍历二叉树">中序遍历二叉树</h4>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 中序遍历左子树;</p>
<p>(2) 访问根结点;</p>
<p>(3) 中序遍历右子树。</p>
<h4 id="后序遍历二叉树">后序遍历二叉树</h4>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 后序遍历左子树;</p>
<p>(2) 后序遍历右子树;</p>
<p>(3) 访问根结点。</p>
<h4 id="递归算法">递归算法</h4>
<h5 id="先序遍历二叉树的实现">先序遍历二叉树的实现</h5>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 访问根结点;</p>
<p>(2) 先序遍历左子树;</p>
<p>(3) 先序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">L</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">R</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">creatNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">	newNode-&gt;data = data;</span><br><span class="line">	newNode-&gt;L = <span class="literal">NULL</span>;</span><br><span class="line">	newNode-&gt;R = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xianXu</span><span class="params">(<span class="keyword">struct</span> Node* tree)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;data);</span><br><span class="line">		xianXu(tree-&gt;L);</span><br><span class="line">		xianXu(tree-&gt;R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tree</span> =</span> creatNode(<span class="number">1</span>);</span><br><span class="line">	tree-&gt;L = creatNode(<span class="number">2</span>);</span><br><span class="line">	tree-&gt;R = creatNode(<span class="number">3</span>);</span><br><span class="line">	tree-&gt;L-&gt;L = creatNode(<span class="number">4</span>);</span><br><span class="line">	tree-&gt;L-&gt;R = creatNode(<span class="number">5</span>);</span><br><span class="line">	xianXu(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历二叉树的实现">中序遍历二叉树的实现</h5>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 中序遍历左子树;</p>
<p>(2) 访问根结点;</p>
<p>(3) 中序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zhongXu</span><span class="params">(<span class="keyword">struct</span> Node* tree)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		zhongXu(tree-&gt;L);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;data);</span><br><span class="line">		zhongXu(tree-&gt;R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历二叉树的实现">后序遍历二叉树的实现</h5>
<p>若二叉树为空，则空操作; 否则:</p>
<p>(1) 后序遍历左子树;</p>
<p>(2) 后序遍历右子树;</p>
<p>(3) 访问根结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">houXu</span><span class="params">(<span class="keyword">struct</span> Node* tree)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		houXu(tree-&gt;L);</span><br><span class="line">		houXu(tree-&gt;R);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;data);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231027091518482.png" alt="image-20231027091518482"></p>
<p>• 时间复杂度：O(n) //每个节点只访问1次</p>
<p>• 空间复杂度：O(n) //栈占用的最大辅助空间</p>
<h4 id="非递归算法">非递归算法</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">l</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">r</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Stack* <span class="title function_">createStack</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> (<span class="keyword">struct</span> Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>, <span class="keyword">struct</span> TreeNode* node)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">stackNode</span> =</span> (<span class="keyword">struct</span> StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> StackNode));</span><br><span class="line">	stackNode-&gt;node = node;</span><br><span class="line">	stackNode-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = stackNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">pop</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">stackNode</span> =</span> <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> =</span> stackNode-&gt;node;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = stackNode-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(stackNode);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _xianXu(<span class="keyword">struct</span> TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">            push(<span class="built_in">stack</span>, current);</span><br><span class="line">            current = current-&gt;l;</span><br><span class="line">        &#125;</span><br><span class="line">        current = pop(<span class="built_in">stack</span>);</span><br><span class="line">        current = current-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _zhongXu(<span class="keyword">struct</span> TreeNode* tree) &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> tree;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (current != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			push(<span class="built_in">stack</span>, current);</span><br><span class="line">			current = current-&gt;l;</span><br><span class="line">		&#125;</span><br><span class="line">		current = pop(<span class="built_in">stack</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">		current = current-&gt;r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">tree</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">	tree-&gt;data = <span class="number">1</span>;</span><br><span class="line">	tree-&gt;l = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">	tree-&gt;l-&gt;data = <span class="number">2</span>;</span><br><span class="line">	tree-&gt;l-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">	tree-&gt;l-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">	tree-&gt;r = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">	tree-&gt;r-&gt;data = <span class="number">3</span>;</span><br><span class="line">	tree-&gt;r-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">	tree-&gt;r-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">	_zhongXu(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="先序遍历">先序遍历</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _xianXu(<span class="keyword">struct</span> TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">            push(<span class="built_in">stack</span>, current);</span><br><span class="line">            current = current-&gt;l;</span><br><span class="line">        &#125;</span><br><span class="line">        current = pop(<span class="built_in">stack</span>);</span><br><span class="line">        current = current-&gt;r;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历">中序遍历</h5>
<p>二叉树中序遍历的非递归算法的关键: 在中序遍历过某结点的整个 左子树后，如何找到该结点的根以及右子树。</p>
<p>基本思路: 1. 建立一个栈 2. 根结点进栈，遍历左子树 3. 根结点出栈，访问根结点，遍历右子树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _zhongXu(<span class="keyword">struct</span> TreeNode* tree) &#123;</span><br><span class="line">	<span class="keyword">if</span> (tree == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> tree;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (current != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			push(<span class="built_in">stack</span>, current);</span><br><span class="line">			current = current-&gt;l;</span><br><span class="line">		&#125;</span><br><span class="line">		current = pop(<span class="built_in">stack</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">		current = current-&gt;r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历">后序遍历</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _houXu(<span class="keyword">struct</span> TreeNode* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> tree;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lastVisited</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            push(<span class="built_in">stack</span>, current);</span><br><span class="line">            current = current-&gt;l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">topNode</span> =</span> <span class="built_in">stack</span>-&gt;top-&gt;node;</span><br><span class="line">        <span class="keyword">if</span> (topNode-&gt;r == <span class="literal">NULL</span> || topNode-&gt;r == lastVisited) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, topNode-&gt;data);</span><br><span class="line">            lastVisited = pop(<span class="built_in">stack</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = topNode-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层次遍历算法">层次遍历算法</h4>
<p>算法设计思路: 使用一个队列</p>
<p>I. 将根结点进队；</p>
<p>II. 队不空时循环: 从队列中出列一个结点*p，访问它；</p>
<p>① 若它有左孩子结点，将左孩子结点进队；</p>
<p>② 若它有右孩子结点，将右孩子结点进队；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Stack* <span class="title function_">createStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> (<span class="keyword">struct</span> Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>, <span class="keyword">struct</span> TreeNode* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">stackNode</span> =</span> (<span class="keyword">struct</span> StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> StackNode));</span><br><span class="line">    stackNode-&gt;node = node;</span><br><span class="line">    stackNode-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = stackNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">pop</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">stackNode</span> =</span> <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> =</span> stackNode-&gt;node;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = stackNode-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(stackNode);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bianLi</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> createStack();</span><br><span class="line">    push(<span class="built_in">stack</span>, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> pop(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left) &#123;</span><br><span class="line">            push(<span class="built_in">stack</span>, current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right) &#123;</span><br><span class="line">            push(<span class="built_in">stack</span>, current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">tree</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    tree-&gt;data = <span class="number">1</span>;</span><br><span class="line">    tree-&gt;left = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    tree-&gt;left-&gt;data = <span class="number">2</span>;</span><br><span class="line">    tree-&gt;left-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;right = (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    tree-&gt;right-&gt;data = <span class="number">3</span>;</span><br><span class="line">    tree-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    bianLi(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">BiNode Queue[MAXNODE]; <span class="comment">//存放队列元素</span></span><br><span class="line"><span class="type">int</span> front,rear; <span class="comment">//队头和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiNode *b)</span> <span class="comment">/*层次遍历二叉树bt*/</span></span><br><span class="line">BTNode *p; SqQueue *qu;</span><br><span class="line">InitQueue(qu); <span class="comment">//初始化队列</span></span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">enQueue(qu, b); <span class="comment">//根结点指针进入队列</span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(qu)) &#123;</span><br><span class="line">deQueue(qu, p); <span class="built_in">printf</span>(“%c”, p-&gt;data); <span class="comment">//出队队首并访问</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>) enQuque(qu, p-&gt;lchild); <span class="comment">//有左孩子时将其进队</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>) enQuque(qu, p-&gt;rchild); <span class="comment">//有右孩子时将其进队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> LevelOrder（BiTree bt） <span class="comment">/*层次遍历二叉树bt*/</span></span><br><span class="line">&#123; BiTree Queue[MAXNODE]; <span class="type">int</span> front,rear;</span><br><span class="line"><span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">front=<span class="number">-1</span>; rear=<span class="number">0</span>; <span class="built_in">queue</span>[rear]=bt;</span><br><span class="line"><span class="keyword">while</span>(front!=rear)</span><br><span class="line">&#123;front++; p=<span class="built_in">queue</span>[front]; visit (p-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>) <span class="comment">/*队首结点的左孩子入队*/</span></span><br><span class="line">&#123; rear++; <span class="built_in">queue</span>[rear]=p-&gt;lchild; &#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>) <span class="comment">/*队首结点的右孩子入队*/</span></span><br><span class="line">&#123; rear++; <span class="built_in">queue</span>[rear]=p-&gt;rchild; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两段代码都是用于进行二叉树的层次遍历（广度优先遍历），但它们之间存在一些区别和不同点：</p>
<ol>
<li><strong>变量名和数据结构：</strong>
<ul>
<li>第一段代码使用 <code>BiNode</code> 和 <code>SqQueue</code> 作为数据结构，其中 <code>BiNode</code> 可能是二叉树节点的结构定义，而 <code>SqQueue</code> 可能是队列的结构定义。这段代码使用了两个不同的结构来表示二叉树节点和队列。</li>
<li>第二段代码使用 <code>BiTree</code> 作为数据结构，表示二叉树节点，同时使用了一个数组 <code>Queue</code> 来模拟队列。这段代码将二叉树节点和队列的表示结合在一起。</li>
</ul>
</li>
<li><strong>队列实现：</strong>
<ul>
<li>第一段代码使用了一个自定义的队列数据结构 <code>SqQueue</code>，它在函数内部进行队列操作，如 <code>enQueue</code> 和 <code>deQueue</code>。这段代码使用了一个单独的队列结构和相关操作。</li>
<li>第二段代码没有使用独立的队列结构，而是使用一个数组 <code>Queue</code> 来模拟队列的行为，通过修改 <code>front</code> 和 <code>rear</code> 指针来表示队列的状态。</li>
</ul>
</li>
<li><strong>函数内部逻辑：</strong>
<ul>
<li>两段代码的函数内部逻辑是类似的，都是通过队列（或队列数组）来实现层次遍历。它们都从根节点开始，逐层将左右孩子节点加入队列，并在每次出队时访问节点。</li>
</ul>
</li>
</ol>
<p>总的来说，这两段代码的目标都是一样的，即实现二叉树的层次遍历，但它们使用了不同的数据结构和实现方式。第一段代码使用了自定义的队列数据结构，而第二段代码则使用了数组来模拟队列。两者的功能是相似的，但具体实现细节不同。</p>
<h3 id="线索二叉树">线索二叉树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">若结点有左子树，则其LChild域指向其左孩子，否则LChild域指向</span><br><span class="line">其前驱结点；若结点有右子树，则其RChild域指向其右孩子，否则</span><br><span class="line">RChild域指向其后继结点。</span><br><span class="line">——这种改变指向的指针称为“线索”</span><br><span class="line">加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）</span><br><span class="line">对二叉树按某种遍历次序使其变为线索二叉树的过程叫做线索化</span><br></pre></td></tr></table></figure>
<h4 id="先序线索二叉树">先序线索二叉树</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231027111925194.png" alt="image-20231027111925194"></p>
<h4 id="中序线索二叉树">中序线索二叉树</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231027111932300.png" alt="image-20231027111932300"></p>
<h4 id="后序线索二叉树">后序线索二叉树</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231027111945284.png" alt="image-20231027111945284"></p>
<h3 id="树和森林">树和森林</h3>
<p>树是由 n (n≥ 0) 个结点组成的有限集合。如果n= 0，称为空树；否则 (n&gt;0)：</p>
<p>（1）有且仅有一个根(root) 结点；</p>
<p>（2）除根以外的其它结点划分为 m (m ≥ 0) 个互不相 交的有限 集合 T0, T1, …, Tm-1。</p>
<h4 id="双亲表示法">双亲表示法</h4>
<p>实现: 定义结构数组存放树的结点，每个节点含两 个域</p>
<p>• 数据域：存放结点本身信息；</p>
<p>• 双亲域：指示本结点的双亲结点在数组中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line"><span class="type">int</span> parent; <span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTree</span>&#123;</span></span><br><span class="line">PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line"><span class="type">int</span> r, n; <span class="comment">//根结点的位置和结点的个数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<h4 id="孩子链表">孩子链表</h4>
<p>把每个结点的孩子结点排列起来，看成是一个线性表， 用单链表存储，则n个结点有n个孩子链表（叶子的孩子链 表为空表）。而n个头结点又组成一个线性表，用顺序表 （含n个元素的数据结构数组）存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//孩子结点结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> child;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="comment">//双亲结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line">ChildPtr firstchild; <span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTree</span>&#123;</span></span><br><span class="line">CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line"><span class="type">int</span> r, n; <span class="comment">//根结点的位置和结点的个数</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>
<h4 id="孩子兄弟表示法">孩子兄弟表示法</h4>
<p>实现: 用二叉链表作树的存储结构，链表中每个结点的两个 指针域分别指向其第一个孩子结点和下一个兄弟结点</p>
<p>• 将树转化为二叉树进行处理，利用二叉树的算法 来实现对树的操作</p>
<p>• 由于树和二叉树都可以用二叉链表作存储结构， 则以二叉链表作媒介可以导出树与二叉树之间的 一个对应关系</p>
<h4 id="将二叉树转换成树">将二叉树转换成树</h4>
<p>① 加线: 若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右 孩子…沿分支找到所有的右孩子，都与p的双亲用连线连起来</p>
<p>② 抹线: 抹掉原二叉树中双亲与右孩子之间的连线</p>
<p>③ 调整: 将结点按层次排列，形成树结构</p>
<h4 id="将树转换成二叉树">将树转换成二叉树</h4>
<p>① 加线: 在兄弟之间加一连线</p>
<p>② 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
<p>③ 旋转：以树的根结点为轴心，将整树顺时针旋转45度</p>
<h4 id="森林转换成二叉树">森林转换成二叉树</h4>
<p>① 将各棵树分别转换成二叉树 ② 将每棵树的根结点用线相连 ③ 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋 转，构成二叉树</p>
<h4 id="二叉树转换成森林">二叉树转换成森林</h4>
<p>①抹线: 将二叉树中根结点与其右孩子连线，及沿右分支 搜索到的所有右孩子间连线全部抹掉，使之变成孤立的 二叉树 ②还原: 将孤立的二叉树还原成树</p>
<h4 id="树的遍历">树的遍历</h4>
<p>• 先根（次序）遍历: 若树不空，则先访问根结点，然后依次先根遍历各棵子树</p>
<p>• 后根（次序）遍历: 若树不空，则先依次后根遍历各棵子树，然后访问根结点</p>
<p>• 按层次遍历: 若树不空，则自上而下自左至右访问树中每个结点</p>
<h4 id="森林的遍历">森林的遍历</h4>
<p>将森林看做由三部分构成:</p>
<ol>
<li>森林中第一棵树的根结点;</li>
<li>森林中第一棵树的子树森林;</li>
<li>森林中其它树构成的森林。</li>
</ol>
<h5 id="先序遍历-2">先序遍历</h5>
<p>若森林不为空，则: 1. 访问森林中第一棵树的根结点; 2. 先序遍历森林中第一棵树的子树森林; 3. 先序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
<h5 id="森林的遍历-2">森林的遍历</h5>
<p>将森林看做由三部分构成: 1. 森林中第一棵树的根结点; 2. 森林中第一棵树的子树森林; 3. 森林中其它树构成的森林。</p>
<h5 id="中序遍历-2">中序遍历</h5>
<p>若森林不为空，则: 1. 中序遍历森林中第一棵树的子树森林; 2. 访问森林中第一棵树的根结点; 3. 中序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
<h3 id="最优二叉树-霍夫曼树">最优二叉树(霍夫曼树)</h3>
<h4 id="霍夫曼树的基本概念">霍夫曼树的基本概念</h4>
<p>路径:从一个结点到另一个结点之间的若干分支</p>
<p>路径长度:路径上的分支数目称为路径长度</p>
<p>结点的路径长度:从根到该结点的路径长度</p>
<p>树的路径长度根到所有结点的路径长度之和;一般记为PL</p>
<p>结点的权:根据应用的需要可以给树的结点赋权值(有着某种含义的值)</p>
<p>结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积； 树的带权路径长度 = 树中所有叶子结点的带权路径之和；通常记作</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/adfsaffsa.png" alt="adfsaffsa"></p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/afsdddd.png" alt="afsdddd"></p>
<p>构造霍夫曼树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree *HT, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    *HT = (HuffmanTree)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        (*HT)[i].lch = <span class="number">0</span>;</span><br><span class="line">        (*HT)[i].rch = <span class="number">0</span>;</span><br><span class="line">        (*HT)[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(*HT)[i].weight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        Select(*HT, i - <span class="number">1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        (*HT)[s1].parent = i;</span><br><span class="line">        (*HT)[s2].parent = i;</span><br><span class="line">        (*HT)[i].lch = s1;</span><br><span class="line">        (*HT)[i].rch = s2;</span><br><span class="line">        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="霍夫曼编码">霍夫曼编码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    HC = new <span class="type">char</span> *[n + <span class="number">1</span>]; <span class="comment">// 分配n个字符编码的头指针向量</span></span><br><span class="line">    <span class="type">char</span> *cd = new <span class="type">char</span>[n]; <span class="comment">// 分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 编码结束符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 逐个字符求Huffman编码</span></span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>) &#123; <span class="comment">// 从叶子结点开始向上回溯，直至根结点</span></span><br><span class="line">            --start; <span class="comment">// 回溯一次start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lch == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 结点是c的左孩子，生成代码0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 结点是c的右孩子，生成代码1</span></span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent;</span><br><span class="line">        &#125; <span class="comment">// 求出第i个字符的编码</span></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start]; <span class="comment">// 为第i个字符编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]); <span class="comment">// 将编码从临时空间cd拷贝到HC的当前行</span></span><br><span class="line">    &#125;</span><br><span class="line">    delete[] cd; <span class="comment">// 释放临时空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图">图</h3>
<h4 id="图的定义和基本术语">图的定义和基本术语</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">图:    G = (V, E)</span><br><span class="line"><span class="code">          V:  顶点（Vertex）的有穷非空集合;  顶点表示数据元素</span></span><br><span class="line"><span class="code">          E:  边（Edge，或称弧Arc）的有穷集合;  </span></span><br><span class="line"><span class="code">                边表示数据元素之间的关系</span></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无向图(Directed Graph, or Digraph):  每条边都是无方向的;</span><br><span class="line">有向图(Undirected Graph, or Undigraph):  每条边都是有方向的。</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于有向图而言，若<span class="language-xml">&lt;x，y&gt;</span>∈E，则<span class="language-xml">&lt;x，y&gt;</span>表示从顶点x到顶点y的一条弧，并称x为弧尾（tail）或起始点(Initial node)，称y为弧头（head）或终端点(Terminal node)</span><br></pre></td></tr></table></figure>
<p><strong>完全图(Completed Graph):</strong>  任意两个点都有一条边相连</p>
<p>**无向完全图：**有n(n-1)/2条边（图中每个顶点和其余n-1个顶点都有边相连）的无向图为完全图。</p>
<p>**有向完全图：**有n(n-1)条边（图中每个顶点和其余n-1个顶点都有弧相连）的有向图为有向完全图。</p>
<p><strong>稀疏图(Sparse Graph):</strong>  有很少边或弧的图（e &lt; n log n）</p>
<p><strong>稠密图(Dense Graph):</strong> 有较多边或弧的图</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际应用中，有时图的边或弧上往往与具有一定意义的数有关，即每一条边都有与它相关的数，称为权(Weight)，这些权可以表示从一个顶点到另一个顶点的距离或耗费等信息。我们将这种带权的图叫做赋权图或网(Network)。</span><br></pre></td></tr></table></figure>
<p>**子图：**设有两个图G=（V，E）和图G/=（V/，E/）,若V/V且E/  E，则称图G/为G的子图(Subgraph)。</p>
<p><strong>邻接:</strong> 有边/弧相连的两个顶点之间的关系</p>
<ul>
<li><strong>无向图:</strong>  存在边(v, v’), 称作v与v’互为邻接点(Adjacent)，即v与v’相邻接;  边(v, v’)依附于(Incident)顶点v和v’ , 或者说边(v, v’)与顶点v和v’ 相关联</li>
<li><strong>有向图:</strong>  存在边&lt; v, v’&gt; ，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v ，或者说弧&lt; v, v’&gt;与顶点v、v’相关联。</li>
</ul>
<p><strong>顶点的度(Degree):</strong></p>
<ul>
<li>对<strong>无向图</strong>而言，<strong>顶点v 的度</strong>是<strong>指和v相关联的边的数目，记作TD(v)</strong></li>
<li>对<strong>有向图</strong>而言，<strong>顶点v的度</strong>是其<strong>入度和出度之和</strong>
<ul>
<li><strong>入度(Indegree):</strong>  以v为终点的有向边的条数，记作ID(v)</li>
<li><strong>出度(Outdegree):</strong>  以v为始点的有向边的条数，记作OD(v)</li>
</ul>
</li>
</ul>
<p><strong>路径(Path):</strong>  接续的边构成的顶点序列</p>
<ul>
<li>对<strong>无向图</strong>而言，从<strong>顶点v到v’<strong>的</strong>路径</strong>是一个顶点序列(v=vi0, vi1, vi2, …, vim= v ’), 其中(vij-1, vij)∈E, 1≤j≤m。</li>
<li>对<strong>有向图</strong>而言，<strong>路径</strong>也是<strong>有向</strong>的，顶点序列应满足&lt;vij-1, vij&gt;∈E，1≤j≤m。</li>
</ul>
<p><strong>路径长度:</strong>  路径上边或弧的数目/权值之和</p>
<p><strong>回路(环):</strong>  第一个顶点和最后一个顶点相同的路径</p>
<p><strong>简单路径:</strong>  路径上顶点均不相同的路径</p>
<p><strong>简单回路(简单环):</strong>  除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103114020694.png" alt=""></p>
<p><strong>连通图:</strong>  在无向图G=（V，{E}）中，若从vi到vj有路径相通，则称顶点vi与vj是连通的。如果对于图中的任意两个顶点vi、vj∈V，vi与vj都是连通的，则称该无向图G为连通图(Connected Graph)。</p>
<p>**强连通图：**在有向图G=（V，{A}）中，若对于每对顶点vi、vj∈V且vi≠vj，从vi到vj和vj到vi都有路径，则称该有向图为强连通图。</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103114120939.png" alt="image-20231103114120939"></p>
<p>**连通分量：**无向图G中的极大连通子图称为G的连通分量(Connected Component)。</p>
<ul>
<li>**极大连通子图：**该子图是G的连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。</li>
</ul>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103114146102.png" alt="image-20231103114146102"></p>
<p>**极小连通子图：**该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通</p>
<p>**生成树：**包含无向图G所有顶点的极小连通子图。它含有图中的全部顶点，但只有足已构成一棵树的n-1条边。</p>
<p>**生成森林：**对非连通图，由各个连通分量的生成树构成的集合</p>
<h4 id="图的类型定义">图的类型定义</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line"><span class="code">	数据对象V： 具有相同特性的数据元素的集合，称为顶点集。</span></span><br><span class="line"><span class="code">	数据关系R： R=&#123;VR&#125;</span></span><br><span class="line"><span class="code">			              VR=&#123;&lt;v,w&gt;|v,w∈V ∧ p(v,w), &lt;v,w&gt;表示从v到w的弧，</span></span><br><span class="line"><span class="code">                                            p(v,w)定义了弧&lt;v,w&gt;的信息&#125;</span></span><br><span class="line"><span class="code">	基本操作P： CreateGraph(): 图的创建操作</span></span><br><span class="line"><span class="code">				  初始条件: 无	操作结果: 生成一个没有顶点空图G</span></span><br><span class="line"><span class="code">				  GetVex(G, v): 获得图中顶点v的值</span></span><br><span class="line"><span class="code">				  初始条件: 图G存在, v是G中顶点	  操作结果: 返回v的值</span></span><br><span class="line"><span class="code">				  ......</span></span><br><span class="line"><span class="code">&#125; ADT Graph</span></span><br></pre></td></tr></table></figure>
<h4 id="图的主要操作">图的主要操作</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CreateGraph(&amp;G, V, VR)</span><br><span class="line"><span class="code">	初始条件:  V是图的顶点集，VR是图中弧的集合。</span></span><br><span class="line"><span class="code">	操作结果:  按V和VR的定义构造图G。</span></span><br><span class="line"><span class="code">DFSTraverse(G)</span></span><br><span class="line"><span class="code">	初始条件:  图G存在。</span></span><br><span class="line"><span class="code">	操作结果:  对图进行深度优先遍历。</span></span><br><span class="line"><span class="code">BFSTraverse(G)</span></span><br><span class="line"><span class="code">	初始条件:  图G存在。</span></span><br><span class="line"><span class="code">	操作结果:  对图进行广度优先遍历。</span></span><br></pre></td></tr></table></figure>
<h4 id="图的存储结构">图的存储结构</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103115148596.png" alt="image-20231103115148596"></p>
<h4 id="邻接矩阵（数组）表示法">邻接矩阵（数组）表示法</h4>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103115229433.png" alt="image-20231103115229433"></p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103115257832.png" alt="image-20231103115257832"></p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103115305844.png" alt="image-20231103115305844"></p>
<p><strong>邻接矩阵的存储表示: 用两个数组分别存储顶点表和邻接矩阵</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100     <span class="comment">//最大定点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;    <span class="comment">//设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;      <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType   vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">	ArcType  arcs[MVNum][MVNum];    <span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;       <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;AMGraph;  <span class="comment">//Adjacency Matrix Graph</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103115417740.png" alt="image-20231103115417740"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123;      <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;     <span class="comment">//输入总顶点数、总边数</span></span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vex[i];                       <span class="comment">//依次输入点的信息</span></span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;G.vexnum; i++)            <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">		<span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;G.vexnum; ++j)</span><br><span class="line">			G.arcs[i][j] = MaxInt;  <span class="comment">//边的权值均设为极大值</span></span><br><span class="line">	<span class="keyword">for</span>( k=<span class="number">0</span>; k&lt; G.arcnum; ++k)&#123;      <span class="comment">//构造邻接矩阵</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;       <span class="comment">//输入一条边所依附的顶点及边的权值</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);         <span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">		G.arcs[i][j] = w;                  <span class="comment">//边&lt;v1, v2&gt;的权值设为w</span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];    <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;权值为w</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">//CreateUDN</span></span><br></pre></td></tr></table></figure>
<p><strong>【补充算法】在图中查找顶点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span> <span class="params">(AMGraph G, VertexType u)</span>&#123;  </span><br><span class="line">	<span class="comment">//在G中查找顶点u，存在返回在顶点表中的下标；否则返回-1</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(u == G.vexs[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图的邻接链表存储表示">图的邻接链表存储表示</h4>
<h5 id="顶点的结点结构">顶点的结点结构</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode * firstarc;       <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode, AdjList[MVNum];     <span class="comment">//AdjList表示邻接表类型</span></span><br></pre></td></tr></table></figure>
<h5 id="弧-边-的结点结构">弧(边)的结点结构</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100       <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>       <span class="comment">//边结点</span></span><br><span class="line">	<span class="type">int</span> adjvex;          <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>       <span class="comment">//指向下一条边的指针</span></span><br><span class="line">	OtherInfo info;      <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;ArcNode</span><br></pre></td></tr></table></figure>
<h5 id="图的结构定义">图的结构定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>       </span><br><span class="line">	AdjList vertices;   </span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;    <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>
<p><strong>采用邻接表表示法创建无向网</strong></p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103130343948.png" alt="image-20231103130343948"></p>
<p><strong>【算法】采用邻接表表示法创建无向网</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123;     <span class="comment">//采用邻接表表示法，创建无向图G</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;       <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;G.vexnum; ++i)&#123;		      <span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;           <span class="comment">//输入顶点值</span></span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;     <span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">	&#125;     <span class="comment">//for</span></span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k&lt;G.arcnum; k++)&#123;		<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;				<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">		i = LocateVex(G, v1);</span><br><span class="line">		j = LocateVex(G, v2);</span><br><span class="line">    (接上页)	</span><br><span class="line">		p1=new ArcNode;			<span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">		p1-&gt;adjvex = j;				<span class="comment">//邻接点的序号为j</span></span><br><span class="line">		p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">		G.vertices[i].firstarc = p1;    	<span class="comment">//将新节点*p1插入顶点vi的边表头部</span></span><br><span class="line">		p2 = new ArcNode;			<span class="comment">//生成另一个对称的新的边结点*p2</span></span><br><span class="line">		p2-&gt;adjvex=i;				<span class="comment">//邻接点序号为i</span></span><br><span class="line">		p2-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">		G.vertices[j].firstarc = p2;	<span class="comment">//将新结点*p2插入顶点vj的边表头部</span></span><br><span class="line">	&#125;   <span class="comment">//for</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;   <span class="comment">//CreateUDG</span></span><br></pre></td></tr></table></figure>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103130608662.png" alt="image-20231103130608662"></p>
<h4 id="邻接矩阵与邻接表示法的关系">邻接矩阵与邻接表示法的关系</h4>
<p>联系:  邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p>
<p>区别:</p>
<ul>
<li>对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）</li>
<li>邻接矩阵的空间复杂度为0(n2)，而邻接表的空问复杂度为0(n+e)</li>
</ul>
<p>用途: 邻接矩阵多用于稠密图的存储（e接近n(n-1)/2）;  而邻接表多用于稀疏图的存储(e&lt;&lt; n2)</p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103130645027.png" alt="image-20231103130645027"></p>
<h4 id="十字链表——用于有向图">十字链表——用于有向图</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">十字链表(Orthogonal List)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</span><br><span class="line">有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。</span><br></pre></td></tr></table></figure>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103152850912.png" alt="image-20231103152850912"></p>
<p><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/image-20231103153006214.png" alt="image-20231103153006214"></p>
<h4 id="图的遍历">图的遍历</h4>
<p>**遍历定义：**从图中的某个顶点出发，按某种方法访问图中的所有顶点且仅访问一次。</p>
<p>**遍历实质：**找每个顶点的邻接点的过程。</p>
<p>**图的特点：**图中可能存在回路，在遍历过程中，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p>
<p><strong>如何避免重复访问？</strong></p>
<p>解决思路:  设置辅助数组visited[n]，用来标记每个被访问的顶点。辅助数组初始状态：visited[i] == 0</p>
<p>若顶点i被访问，则visited[i] = 1</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jinmu1108.github.io">Jinmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinmu1108.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">https://jinmu1108.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinmu1108.github.io" target="_blank">J1Nmu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E8%A1%A8/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构复习表</div></div></a></div><div class="next-post pull-right"><a href="/JAVA/JAVA/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Crypto/RC4/Crypto-RC4/" title="Crypto-RC4"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">Crypto-RC4</div></div></a></div><div><a href="/Crypto/AES/Crypto-AES/" title="Crypto-AES"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">Crypto-AES</div></div></a></div><div><a href="/Crypto/RSA/Crypto-RSA/" title=""><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title"></div></div></a></div><div><a href="/Crypto/%E7%90%86%E8%AE%BA/Crypto%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" title="Crypto理论知识"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">Crypto理论知识</div></div></a></div><div><a href="/Web/JWT/JWT/" title="JWT"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">JWT</div></div></a></div><div><a href="/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/" title="伪协议"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">伪协议</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://jinmu-1313986858.cos.ap-beijing.myqcloud.com/liujin.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jinmu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jinmu1108"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">线性结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">线性结构特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">顺序表(顺序存储结构)的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">顺序表的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">链式存储有关的术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">链表(链式存储结构)的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">链表的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">队列的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.</span> <span class="toc-text">树的定义和基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">树的定义和基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">树的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">树的基本操作 (抽象数据类型见二叉树)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">二叉树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.4.</span> <span class="toc-text">满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.5.</span> <span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.6.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">二叉树的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">二叉树的链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">三叉链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.7.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">先序遍历二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">中序遍历二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">后序遍历二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">递归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.4.1.</span> <span class="toc-text">先序遍历二叉树的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.4.2.</span> <span class="toc-text">中序遍历二叉树的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.4.3.</span> <span class="toc-text">后序遍历二叉树的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.5.</span> <span class="toc-text">非递归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.7.5.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.7.5.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.7.5.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.6.</span> <span class="toc-text">层次遍历算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.8.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">先序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">中序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">后序线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.4.9.</span> <span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">孩子链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.4.9.3.</span> <span class="toc-text">孩子兄弟表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91"><span class="toc-number">1.4.9.4.</span> <span class="toc-text">将二叉树转换成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.9.5.</span> <span class="toc-text">将树转换成二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.9.6.</span> <span class="toc-text">森林转换成二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-number">1.4.9.7.</span> <span class="toc-text">二叉树转换成森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.9.8.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.9.9.</span> <span class="toc-text">森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.9.9.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.9.9.2.</span> <span class="toc-text">森林的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.4.9.9.3.</span> <span class="toc-text">中序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.4.10.</span> <span class="toc-text">最优二叉树(霍夫曼树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">霍夫曼树的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">霍夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.4.11.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">图的定义和基本术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">图的类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.11.3.</span> <span class="toc-text">图的主要操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.11.4.</span> <span class="toc-text">图的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.4.11.5.</span> <span class="toc-text">邻接矩阵（数组）表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.4.11.6.</span> <span class="toc-text">图的邻接链表存储表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.11.6.1.</span> <span class="toc-text">顶点的结点结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%A7-%E8%BE%B9-%E7%9A%84%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.11.6.2.</span> <span class="toc-text">弧(边)的结点结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.11.6.3.</span> <span class="toc-text">图的结构定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.11.7.</span> <span class="toc-text">邻接矩阵与邻接表示法的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.4.11.8.</span> <span class="toc-text">十字链表——用于有向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.11.9.</span> <span class="toc-text">图的遍历</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散数学"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学">离散数学</a><time datetime="2023-12-25T13:13:33.605Z" title="发表于 2023-12-25 21:13:33">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E8%A1%A8/" title="数据结构复习表"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构复习表"/></a><div class="content"><a class="title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E8%A1%A8/" title="数据结构复习表">数据结构复习表</a><time datetime="2023-12-20T14:56:44.881Z" title="发表于 2023-12-20 22:56:44">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" title="数据结构与算法分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法分析"/></a><div class="content"><a class="title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" title="数据结构与算法分析">数据结构与算法分析</a><time datetime="2023-12-20T14:53:52.858Z" title="发表于 2023-12-20 22:53:52">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JAVA/JAVA/" title="JAVA"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA"/></a><div class="content"><a class="title" href="/JAVA/JAVA/" title="JAVA">JAVA</a><time datetime="2023-09-07T14:56:22.393Z" title="发表于 2023-09-07 22:56:22">2023-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%9D%B6%E5%9C%BA/ATT-CK/ATT&amp;CK(%E4%BA%94)/" title="ATT&amp;CK(五)"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ATT&amp;CK(五)"/></a><div class="content"><a class="title" href="/%E9%9D%B6%E5%9C%BA/ATT-CK/ATT&amp;CK(%E4%BA%94)/" title="ATT&amp;CK(五)">ATT&amp;CK(五)</a><time datetime="2023-08-19T08:59:17.051Z" title="发表于 2023-08-19 16:59:17">2023-08-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jinmu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>